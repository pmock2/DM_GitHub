package teamHarambe;

import java.util.Calendar;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

public class Schedule {
	Week[] schedule;
	Calendar startDate;
	List<Match> matches = new LinkedList<>();

	public Schedule(List<Team> teamlist, List<Referee> refereelist, Calendar startDate) {
		this.startDate = startDate;
		generateSchedule(shuffleTeams(teamlist), refereelist);
	}
	
	public Schedule(Week[] weekArray) {
		schedule = weekArray;
	}

	public String toString() {
		String s = "";

		for (int week=0; week < schedule.length; week++) {
			s += "Week "+(week+1)+":\n" + schedule[week].toString() + "\n";
		}

		return s;
	}
	
	public String toJSON() {
		String s = "{\n";
		
		for (int week=0; week < schedule.length; week++) {
			s += "\t\t\"Week" + week + "\" : " + schedule[week].toJSON() + (week+1 == schedule.length ? "" : ",") + "\n";
		}
		
		s += "\t}";
		return s;
	}
	
	public List<Match> getMatches() {
		return matches;
	}

	private List<Team> shuffleTeams(List<Team> list) {
		Random rand = new Random();

		for (int i=list.size()-1; i > 0; i--) {
			int index = rand.nextInt(i+1);
			Team temp = list.get(index);
			list.set(index, list.get(i));
			list.set(i, temp);
		}

		return list;
	}
	
	int msInWeek = 1000 * 60 * 60 * 24 * 7;
	private Calendar getDateFromWeek(int week) {
		long startMs = startDate.getTimeInMillis();
		Calendar newDate = Calendar.getInstance();
		newDate.setTimeInMillis(startMs + (msInWeek * week));
		
		
		return newDate;
	}

	/*
	 * Algorithm used is called the "Polygon method of round-robin scheduling"
	 * Explanation and Visual examples of the algorithm can be found here:
	 * 					http://mathforum.org/library/drmath/view/54715.html
	 *
	 * Supports even or odd number of teams, though with odd #teams each team
	 * will have an idle/bye week
	 *
	 * Minimum required #weeks = #teams if odd or #teams-1 if even
	 * #matches per week required for that amount of weeks = floor(#teams/2)
	 *
	 * Probably room to improve method's differentiation between even/odd #teams
	 */
	private void generateSchedule(List<Team> list, List<Referee> Rlist) {
		Random rand = new Random();
		Team pivot = null;
		boolean evenNumTeams = list.size() % 2 == 0;
		int matchesPerWeek = list.size()/2;
		List<Referee> temp;
		temp = (List)((LinkedList)Rlist).clone();


		if (evenNumTeams) {
			pivot = list.get(0);
			list = list.subList(1, list.size());
		}

		for (int offset=0; offset < week.length; offset++) {
			Calendar weekDate = getDateFromWeek(offset);
			if (temp.size() > 0)
			{
				temp.clear();
			}
			temp = (List)((LinkedList)Rlist).clone();
			int tempInt;

			if (evenNumTeams) {
				tempInt = rand.nextInt(temp.size()) + 0;
				matches.add(new Match(matches.size(), pivot, list.get(offset), temp.get(tempInt), weekDate));
				temp.remove(tempInt);
			}
			for (int i=1; i < weekMatches.length +  (evenNumTeams ? 0 : 1); i++) {
				int slot0 = (i+offset);
				int slot1 = slot0 + (list.size()-(2*i));
				tempInt = rand.nextInt(temp.size()) + 0;
				weekMatches[evenNumTeams ? i : i-1] = new Match(list.get(slot0 % list.size()), list.get(slot1 % list.size()), temp.get(tempInt), weekDate);
				temp.remove(tempInt);
			}

			week[offset] = new Week(weekMatches);
		}

		this.schedule = week;
	}
}